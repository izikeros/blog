#!/usr/bin/env python3
"""
Remove Anchor ID Elements from Markdown Files

Removes <a id="..."></a> elements that are typically generated by MarkdownTOC
and placed just above headings. These create duplicate IDs since headings
already get auto-generated IDs.

Usage:
    python scripts/remove_anchor_ids.py [--dry-run] [--verbose] [path]

Arguments:
    path        Path to scan (default: content/posts)
    --dry-run   Show what would be changed without modifying files
    --verbose   Show detailed output for each file

Examples:
    python scripts/remove_anchor_ids.py --dry-run
    python scripts/remove_anchor_ids.py content/posts/posts/2023/
    python scripts/remove_anchor_ids.py --verbose content/posts/notes/
"""

import argparse
import re
from pathlib import Path


def remove_anchor_ids(content: str, verbose: bool = False) -> tuple[str, int]:
    """
    Remove <a id="..."></a> anchor elements from content.
    
    Matches patterns like:
        <a id="tutorial"></a>
        <a id="use-pillow"></a>
        <a id="step-1-installing-required-libraries"></a>
    
    Returns (modified_content, count_of_removals).
    """
    # Pattern matches <a id="..."></a> with optional whitespace
    # Also captures the newline after if present
    pattern = r'<a\s+id=["\'][^"\']+["\']\s*>\s*</a>\s*\n?'
    
    matches = list(re.finditer(pattern, content, re.IGNORECASE))
    
    if not matches:
        return content, 0
    
    if verbose:
        for match in matches:
            # Extract the id value for reporting
            id_match = re.search(r'id=["\']([^"\']+)["\']', match.group())
            if id_match:
                print(f"    Removing anchor: <a id=\"{id_match.group(1)}\"></a>")
    
    # Remove all matches
    new_content = re.sub(pattern, '', content, flags=re.IGNORECASE)
    
    return new_content, len(matches)


def process_file(filepath: Path, dry_run: bool = False, verbose: bool = False) -> tuple[bool, int]:
    """
    Process a single markdown file.
    
    Returns (was_modified, removal_count).
    """
    try:
        content = filepath.read_text(encoding='utf-8')
    except Exception as e:
        print(f"  Error reading {filepath}: {e}")
        return False, 0
    
    new_content, removals = remove_anchor_ids(content, verbose)
    
    if removals == 0:
        return False, 0
    
    if dry_run:
        print(f"  Would remove {removals} anchor id(s) from {filepath}")
    else:
        try:
            filepath.write_text(new_content, encoding='utf-8')
            print(f"  Removed {removals} anchor id(s) from {filepath}")
        except Exception as e:
            print(f"  Error writing {filepath}: {e}")
            return False, 0
    
    return True, removals


def scan_directory(path: Path, dry_run: bool = False, verbose: bool = False) -> tuple[int, int, int]:
    """
    Scan directory for markdown files and remove anchor IDs.
    
    Returns (files_scanned, files_modified, total_removals).
    """
    files_scanned = 0
    files_modified = 0
    total_removals = 0
    
    # Find all markdown files
    md_files = list(path.rglob('*.md'))
    
    print(f"Scanning {len(md_files)} markdown files in {path}...")
    
    for filepath in sorted(md_files):
        files_scanned += 1
        
        if verbose:
            print(f"\nProcessing: {filepath}")
        
        modified, removals = process_file(filepath, dry_run, verbose)
        
        if modified:
            files_modified += 1
            total_removals += removals
    
    return files_scanned, files_modified, total_removals


def main():
    parser = argparse.ArgumentParser(
        description='Remove <a id="..."></a> anchor elements from markdown files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument(
        'path',
        nargs='?',
        default='content/posts',
        help='Path to scan (default: content/posts)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show what would be changed without modifying files'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed output for each file'
    )
    
    args = parser.parse_args()
    
    # Resolve path relative to script location or current directory
    path = Path(args.path)
    if not path.is_absolute():
        # Try relative to script's parent directory (blog root)
        script_dir = Path(__file__).parent.parent
        path = script_dir / args.path
        if not path.exists():
            # Try relative to current directory
            path = Path(args.path)
    
    if not path.exists():
        print(f"Error: Path '{args.path}' does not exist")
        return 1
    
    if args.dry_run:
        print("DRY RUN - no files will be modified\n")
    
    files_scanned, files_modified, total_removals = scan_directory(
        path, 
        dry_run=args.dry_run, 
        verbose=args.verbose
    )
    
    print(f"\n{'='*50}")
    print(f"Summary:")
    print(f"  Files scanned:    {files_scanned}")
    print(f"  Files modified:   {files_modified}")
    print(f"  Anchors removed:  {total_removals}")
    
    if args.dry_run and files_modified > 0:
        print(f"\nRun without --dry-run to apply changes.")
    
    return 0


if __name__ == '__main__':
    exit(main())
